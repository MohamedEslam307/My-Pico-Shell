#include <stdio.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <string.h>
#include "linkedlist.h"

#define MAX_PATH_SIZE	100

/**
 * @breif : this funtion display a line of text like echo in the shell
 *          it's also support multiple spaces  
 * 	    	
 * @parameters :
 *
 * @return : 
 *
 */
char my_echo(char **parsed_input_string, char arguments_size);
/**
 * @breif : 
 *
 * @parameters :
 *
 * @return :
 *
 */
char my_cd(char **parsed_input_string, char arguments_size);
/**
 * @breif :
 *
 * @parameters :
 *
 * @return :
 *
 */
char my_pwd(void);
/**
 * @breif :
 *
 * @parameters :
 *
 * @return :
 *
 */
char **parse_line(char *string, char *arguments_num);
/**
 * @breif :
 *
 * @parameters :
 *
 * @return :
 *
 */
char execute_io_redirections(char **parsed_input_string,
			     char arguments_size);
/**
 * @breif :
 *
 * @parameters :
 *
 * @return :
 *
 */
char execute_output_redirection(char *output_file);
/**
 * @breif :
 *
 * @parameters :
 *
 * @return :
 *
 */
char execute_error_redirection(char *error_file);
/**
 * @breif :
 *
 * @parameters :
 *
 * @return :
 *
 */
char execute_input_redirection(char *input_file);

int main()
{
    char *command_line;
    char **parsed_input_string;
    int size_input_string = 0;
    char arguments_size = 0;
    unsigned long n = 0;
    char ret = 0;
    linkedlist list;
    pid_t pid_ret;
    int wstatus;
    list.listSize = 0;
    list.head = NULL;
    printf("Welcome To My Shell \n");

    while (1) {
	printf(">>>>");

	size_input_string = getline(&command_line, &n, stdin);	// get the command line from user

	if ((command_line[0] == '\n')) {
	    continue;
	}

	command_line[strlen(command_line) - 1] = 0;	//remove '\n' from the end of the line
	parsed_input_string = parse_line(command_line, &arguments_size);	//parsing the line into 2-d array
	addNode(&list, parsed_input_string, &arguments_size);
	//printf("command_line = %s\n",command_line);
	//printf("list_head = %s\n",list.head->Data);
	//printf("size = %d , cmd = %s\n",list->listSize,AddedNode->Data);

	if (parsed_input_string != NULL) {

	    if ((strcmp(parsed_input_string[0], "exit") == 0)) {
		break;
	    } else if (strcmp(parsed_input_string[0], "history") == 0) {
		pid_ret = fork();
		if (pid_ret > 0) {
		    //wait the child process to terminate
		    wait(&wstatus);
		} else if (pid_ret == 0) {
		    ret =
			execute_io_redirections(parsed_input_string,
						arguments_size);
		    //execute the command
		    if (ret == 0) {
			Print(&list);
			return 0;
		    } else {
			printf
			    ("ERROR: faild to calculate number of redirections\n");
		    }
		} else {
		    printf("ERROR: I could not get a child\n");
		}

	    } else if (strcmp(parsed_input_string[0], "echo") == 0) {
		pid_ret = fork();
		if (pid_ret > 0) {
		    //wait the child process to terminate
		    wait(&wstatus);
		} else if (pid_ret == 0) {
		ret =
                        execute_io_redirections(parsed_input_string,
                                                arguments_size);

		    //execute the command
		    ret = my_echo(parsed_input_string, arguments_size);
		    return ret;
		} else {
		    printf("ERROR: I could not get a child\n");
		}
	    } else if ((strcmp(parsed_input_string[0], "cd") == 0)) {
		pid_ret = fork();
                if (pid_ret > 0) {
                    //wait the child process to terminate
                    wait(&wstatus);
                } else if (pid_ret == 0) {
                ret =
                        execute_io_redirections(parsed_input_string,
                                                arguments_size);

                    //execute the command
		    ret = my_cd(parsed_input_string, arguments_size);

                    return ret;
                } else {
                    printf("ERROR: I could not get a child\n");
                }

	    } else if ((strcmp(parsed_input_string[0], "pwd") == 0)) {
		pid_ret = fork();
		if (pid_ret > 0) {
		    //wait the child process to terminate
		    wait(&wstatus);
		} else if (pid_ret == 0) {
			ret =
                        execute_io_redirections(parsed_input_string,
                                                arguments_size);

		    //execute the command
		    ret = my_pwd();
		    return ret;
		} else {
		    printf("ERROR: I could not get a child\n");
		}
	    } else {
		//fork the process to create a chile process to execute the command
		pid_ret = fork();
		if (pid_ret > 0) {
		    //wait the child process to terminate
		    wait(&wstatus);
		} else if (pid_ret == 0) {
			ret =
                        execute_io_redirections(parsed_input_string,
                                                arguments_size);

		    //execute the command
		    execvp(parsed_input_string[0], parsed_input_string);
		    //if the execvp function executed correctly the program won't return here
		    printf("ERROR: Command not found\n");
		    return -1;
		} else {
		    printf("ERROR: I could not get a child\n");
		}
	    }

	    free(command_line);
	    command_line = NULL;
	}
    }
    return 0;
}

char execute_error_redirection(char *error_file)
{
    char ret = 1;
    int file_descriptor = 0;
    if (NULL == error_file) {
	ret = 1;
    } else {
	file_descriptor =
	    open(error_file, O_RDWR | O_CREAT | O_TRUNC, 0644);

	if (file_descriptor != -1) {
	    //printf("File created successfully\n");
	    ret = dup2(file_descriptor, 2);
	    ret = close(file_descriptor);
	} else {
	    printf("%s Faild to be created\n", error_file);
	    ret = 1;
	}
    }
    return ret;

}

char execute_input_redirection(char *input_file)
{
    char ret = 1;
    int file_descriptor = 0;
    if (NULL == input_file) {
	ret = 1;
    } else {
	file_descriptor =
	    open(input_file, O_RDWR | O_CREAT | O_TRUNC, 0644);

	if (file_descriptor != -1) {
	    //printf("File created successfully\n");
	    ret = dup2(file_descriptor, 0);
	    ret = close(file_descriptor);
	} else {
	    printf("%s Faild to be created\n", input_file);
	    ret = 1;
	}
    }
    return ret;

}

char execute_output_redirection(char *output_file)
{
    char ret = 1;
    int file_descriptor = 0;
    if (NULL == output_file) {
	ret = 1;
    } else {
	file_descriptor =
	    open(output_file, O_RDWR | O_CREAT | O_TRUNC, 0644);

	if (file_descriptor != -1) {
	    printf("File created successfully\n");
	    ret = dup2(file_descriptor, 1);
	    ret = close(file_descriptor);
	} else {
	    printf("%s Faild to be created\n", output_file);
	    ret = 1;
	}
    }
    return ret;

}

char execute_io_redirections(char **parsed_input_string,
			     char arguments_size)
{
    char ret = 1;
    if ((NULL == parsed_input_string)) {
	ret = 1;
    } else {
	for (int index = 0; index < arguments_size; index++) {
	    if ((strcmp(parsed_input_string[index], ">") == 0)) {
		ret =
		    execute_output_redirection(parsed_input_string
					       [index + 1]);
	    } else if ((strcmp(parsed_input_string[index], "2>") == 0)) {
		ret =
		    execute_error_redirection(parsed_input_string
					      [index + 1]);

	    } else if ((strcmp(parsed_input_string[index], "<") == 0)) {
		ret =
		    execute_input_redirection(parsed_input_string
					      [index + 1]);
	    } else {
		continue;
	    }
	}
    }
    return ret;
}

char my_echo(char **parsed_input_string, char arguments_size)
{
    char ret = 1;
    if (NULL == parsed_input_string) {
	ret = 1;
    } else {
	if (1 == arguments_size) {
	    printf("\n");	//if the user echo nothing it prints new line
	    ret = 0;
	} else {
	    char arg_index = 1;
	    //printing the arguments the user entered
	    for (arg_index = 1; arg_index < arguments_size; arg_index++) {
		printf("%s ", parsed_input_string[arg_index]);
	    }
	    printf("\n");
	}
    }
    return ret;
}

char my_cd(char **parsed_input_string, char arguments_size)
{
    char ret = 1;
    if (NULL == parsed_input_string) {
	ret = 1;
    } else {
	if (2 == arguments_size) {
	    //chdir returns 0 when it execute correctly 
	    if (chdir(parsed_input_string[1]) != 0) {
		printf("directory can't be reatched\n");
		ret = 1;
	    }
	} else {
	    printf("wrong number of argumenrs to cd\n");
	    ret = 0;
	}
    }
    return ret;
}

char my_pwd(void)
{
    char ret = 1;
    char *current_path = NULL;
    /*this function returns the path as string and null if the size exceeds max path size */
    current_path = getcwd(NULL, MAX_PATH_SIZE);
    if (NULL == current_path) {
	printf("size exceeds max path size current directory\n");
	ret = 1;
    } else {
	printf("%s\n", current_path);
	/*now freeing the allocated array */
	free(current_path);
	ret = 0;
    }
    return ret;
}

char **parse_line(char *string, char *arguments_num)
{
    char **parsed_string = NULL;
    int token_size = 0;
    int string_size = strlen(string);
    int arr_index = 0;
    *arguments_num = 1;
    //remove the spaces before the command line
    while ((arr_index < string_size) && (string[arr_index] == ' ')) {
	arr_index++;
	//printf("Number of spaces =%d\n", arr_index);
    }
    //remove the spaces after the command line
    while ((string_size > 0) && (string[string_size - 1] == ' ')) {
	// printf("string size =%d\n", string_size);
	string_size--;
    }
	char quotes_flag = 0;
    //printf("String size =%d\n", string_size);
    //this loop counts the number of arguments and skip spaces
    while (arr_index < string_size) {
	if (string[arr_index] == ' ') {	//skip spaces if the user pressed between arguments
	    if ((string[arr_index + 1] == ' ')) {
		arr_index++;
		continue;
	    } else {
		(*arguments_num)++;
		arr_index++;
	    }
	}else{
		arr_index++;
	}
    }
    printf("Number of arguments =%d\n", *arguments_num);
    char *token = strtok(string, " ");	//make token points to the frist word
    if (token == NULL) {	//there was no string
	*arguments_num = 0;
	parsed_string = NULL;
    } else {
	parsed_string = (char **) malloc(*arguments_num * sizeof(char *));	//allocate memory space by number of arguments
	for (arr_index = 0; arr_index < *arguments_num; arr_index++) {
	    token_size = strlen(token);	//calculate the size of every argument
	    parsed_string[arr_index] = (char *) malloc(token_size * sizeof(char));	//allocate memory space for every argument
	    strcpy(parsed_string[arr_index], token);	//copy a argument into an array elemnt
	    token = strtok(NULL, " ");	//make token points to the next word
	}
	for (int i = 0; i < *arguments_num; i++) {
	    //printf("%s\n", parsed_string[i]);
	}
	// printf("Number of arguments =%d\n", *arguments_num);
	return parsed_string;
    }
}
